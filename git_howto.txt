20170117

[Install for Windows]
1. 搜索 "git 安装"
2. 安装 msysgit 

[SSH GEN]
1. 右键git bash here
2. 命令行中输入 ssh-keygen -t rsa -C "xxxxxx@yy.com"
3. 把生成的id_rsa.pub中的内容复制到github/personal settings/SSH and GPG keys/New SSH key

[git branch]
git branch 分支名                           // 创建分支
git checkout 分支名                         // 切换到某分支
git branch -d 分支名                        // 删除某分支
git branch                                  // 列出所有分支
git branch -a                               // 查看远程分支
git branch --merged/--no-merged             // 查看哪些分支已（未）并入当前分支
git checkout -b 分支名                      // 创建并切换到某分支
git merge 分支名                            // 把某分支合并到当前分支

远程分支表示法
远程仓库名/分支名

远程分支是本地分支push到服务器的时候产生的。

[git push]
git push 远程仓库名 本地分支：远程分支      // 把本地分支推送到远程分支
git push 远程仓库名 分支名                  // 简化版


git commit -m 'comment'                     // 不打开vi提交
git commit -m 'comment' -a                  // add + commit


QA: Why git need add before commit?
AN:
呃，，，，好像现有的答案还是没有到达那个关键点啊。
当然，最直接的原因就是git发明了一个叫做暂存区的概念，但是为什么要发明这个概念呢？没有暂存区可以不？为什么一定要有暂存区，这才是真正的问题好吧。
要解释这个问题，首先要回到GIT的前辈上来，SVN，集中式源代码管理工具的集大成者。
我们知道SVN相较于第一代源代码管理工具如VSS、CVS有几个显著的区别，其中最重要的特性之一就是原子性提交，每一个提交都是由多个文件的修改组成，而且这个提交是原子性的，要么这些修改全部成功，要么全部失败。
原子性提交带来的好处是显而易见的，这使得我们把项目整体还原到某个阶段或者时间点变得极为简便，就这一点SVN就完虐VSS等源代码管理工具。
Git作为目前逼格最高的源代码管理工具，SVN这个优良的特性显然是要借鉴的。但是Linus马上发现了一个麻烦事儿，在命令行下面选择要提交的修改，还真TM是个麻烦事儿，因为用SVN的时候我们都是这么玩的：
你妹啊，虽然GUI逼格相当的低，但是在这个场景下，可比命令行要方便得多了。这样一来，Git用户还能不能愉快的玩(zhuang)耍(bi)了？
显然这点小问题完全难不倒Linus这么一位旷世奇才。我们只需要在commit前面，发明一个暂存区的概念就好了，这个暂存区是可以随意的将各种文件的修改放进去的，这样我们就可以用多个指令精确的挑选出我们需要提交的所有修改，然后再一次性的（原子性的）提交到版本库，问题就完美的解决了。
而且，如果用户觉得这样实在是多此一举的话，可以自定义一个小脚本哦，，，，反正其实你们现在用的这些git命令，其实大部分都是一个批处理脚本哦。
AD: https://www.zhihu.com/question/19946553
SM: 每次修改可能包含多个功能，单个提交繁琐，全部提交只能全部恢复，如果修改包含多个功能，会带来不方便。加入add后，可以对每次提交做控制，一次修改可以按功能分多次提交，则以后恢复时，可以按功能点进行快照恢复，在复杂系统中，此功能非常必要和实用。

[git tag]
git log --oneline                           // 显示提交历史
git tag -a v1.01 -m "v1.01" 75a873d         // 为某提交版本75a873d打标签，-a是添加标签，-m是添加注释
git push origin -tags                       // 提交标签到远程仓库
git tag -d v1.01                            // 删除标签
git push origin :refs/tags/v1.01            // 删除远程标签
git tag                                     // 查看标签
git checkout [tagname]                      // 切换到标签
git show v0.1.2                             // 查看标签版本信息

20180511
checkout 远程非master分支
一键拉取本地上不存在的远程分支：git checkout -b new_branch origin/new_branch. 此外不要在一个问题提多个问题，特别是和题目无关的
//!!!!! 这个命令更好用！
$ git checkout -t origin/develop
//!!!!

20180510
问题描述
我们每次使用命令
git clone git@gitlab.xxx.com:xxxxx.git
默认 clone 的是这个仓库的 master 分支。如果最新的代码不在 master 分支上，该如何拿到呢？如下图所示，最新的代码可能在daily/1.4.1分支上，我们希望拿到这个分支上的代码。
解决方法
直接使用命令
git branch -r #查看远程分支 或
git branch -a #查看所有分支
会显示
origin/HEAD -> origin/master
origin/daily/1.2.2
origin/daily/1.3.0
origin/daily/1.4.1
origin/develop
origin/feature/daily-1.0.0
origin/master
然后直接
git checkout origin/daily/1.4.1
就好了。。。
git clone 默认会把远程仓库整个给clone下来; 
但只会在本地默认创建一个master分支
可以使用checkout命令来把远程分支取到本地
或者使用-t参数，它默认会在本地建立一个和远程分支名字一样的分支
折叠展开复制代码
$ git checkout -t origin/daily/1.4.1
也可以使用fetch来做：
$ git fetch origin python_mail.skin:python_mail.skin
不过通过fetch命令来建立的本地分支不是一个track branch，而且成功后不会自动切换到该分支上- z) t: R4 p- s6 _2 d3 a
注意：不要在本地采用如下方法：
$ git branch python_mail.skin
$ git checkout python_mail.skin
$ git pull origin python_mail.skin:python_mail.skin
因为，这样建立的branch是以master为基础建立的，再pull下来的话，会和master的内容进行合并，有可能会发生冲突... 

20180528
SSH
ssh-keygen -t rsa -C "email@xx"
copy ~/.ssh/id_rsa.pub to github web ssh setting!!
// test
ssh -T git@github.com

20191002
how to set ignore?
git config --global core.excludesfile ~/.gitignore_global

20191003
git add -A // add all modified, deleted and new created files
git add -u // add all modified and deleted files, exclude new created files!
git add . // add all modified and new created files, exclude deleted files!
